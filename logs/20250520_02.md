## ✔ 背景と課題
現在の **TaskItem** ではダブルクリック時に
- ✅ **チェックボックスのトグル**
- ✅ タスク名の **取り消し線の ON/OFF**
が発火し、**文字列の編集モード**には入れません。
ユーザーがタスク名を直接書き換えられるように、**編集モード（入力 → 保存）** を組み込みます。

---

## 🗺️ 実装概要
1. **`isEditing` ステート** をタスク行単位で持つ
2. ラベル（Typography など）を `onDoubleClick` で **編集モードに切替**
3. 編集モード中は **`<TextField>`**（または `contentEditable`）を描画し、`onBlur` または **Enter / Esc** キーで確定 or キャンセル
4. `Checkbox` クリックと編集ダブルクリックを **イベント的に分離**（`e.stopPropagation()`）
5. 変更内容を **API (`updateTask`)** で永続化
6. UI/UX: 編集中は取り消し線を外し、Esc で元に戻す

---

## 🛠️ 具体的手順 (例: `frontend/src/features/tasks/components/TaskItem.tsx`)
```tsx
import { useState, useRef, useEffect, useCallback } from 'react';
import { Checkbox, Typography, TextField, ListItem } from '@mui/material';

export const TaskItem = ({ task }) => {
  const [isEditing, setIsEditing] = useState(false);
  const [title, setTitle]   = useState(task.title);
  const inputRef            = useRef<HTMLInputElement>(null);

  /* 1️⃣ 完了トグルは Checkbox だけが担当 */
  const handleToggle = () => toggleTaskCompleted(task.id);

  /* 2️⃣ 編集モード開始 */
  const startEdit = (e: React.MouseEvent) => {
    e.stopPropagation();   // Checkbox の click を阻止
    setIsEditing(true);
  };

  /* 3️⃣ 変更確定ロジック */
  const commit = useCallback(() => {
    const newTitle = title.trim();
    if (newTitle && newTitle !== task.title) {
      updateTask({ id: task.id, title: newTitle }); // ← API 呼び出し
    } else {
      setTitle(task.title); // 無変更ならロールバック
    }
    setIsEditing(false);
  }, [title, task]);

  /* 4️⃣ フォーカス制御 */
  useEffect(() => { if (isEditing) inputRef.current?.focus(); }, [isEditing]);

  return (
    <ListItem divider disablePadding>
      <Checkbox checked={task.completed} onClick={handleToggle} />

      {isEditing ? (
        <TextField
          inputRef={inputRef}
          size="small"
          fullWidth
          value={title}
          onChange={e => setTitle(e.target.value)}
          onBlur={commit}
          onKeyDown={e => {
            if (e.key === 'Enter') commit();
            if (e.key === 'Escape') { setTitle(task.title); setIsEditing(false); }
          }}
          sx={{ ml: 1 }}
        />
      ) : (
        <Typography
          onDoubleClick={startEdit}
          sx={{
            ml: 1,
            flex: 1,
            cursor: 'text',
            textDecoration: task.completed ? 'line-through' : 'none'
          }}
        >
          {task.title}
        </Typography>
      )}

      {/* 既存の時刻・＋・ゴミ箱アイコンなどはそのまま */}
    </ListItem>
  );
};
````

### 🔑 ポイント

| ポイント                      | 説明                           |
| ------------------------- | ---------------------------- |
| `stopPropagation()`       | ダブルクリック時に完了トグルを発火させない        |
| `useEffect` で `autoFocus` | クリック → 即入力可能                 |
| Enter / Blur              | 自動保存                         |
| Esc                       | 変更を破棄して表示モードへ戻す              |
| `updateTask` API          | PATCH `/tasks/:id` などでタイトル更新 |

---

## ⛏️ コード差分 (パッチイメージ)

```diff
- <Typography sx={{ textDecoration: completed ? 'line-through': 'none' }}>
-   {task.title}
- </Typography>
+ {isEditing ? (
+   <TextField ... />
+ ) : (
+   <Typography onDoubleClick={startEdit} ...>
+     {task.title}
+   </Typography>
+ )}
```

---

## 📚 参考文献

* React で「ダブルクリック → span ↔ input」編集を実装する基本パターン
* `contentEditable` を React に組み込む際の注意点と `dangerouslySetInnerHTML` サンプル
* LogRocket の汎用 `Editable` コンポーネント実装例（Tab ナビゲーションやフォーカス処理）([blog.logrocket.com][1])

---

## ✅ 次のアクション

1. **ブランチ** `feature/edit-task-title` を切る
2. 上記変更をコミット → `pnpm dev` で動作確認
3. PR 作成 & レビュー依頼

以上、よろしくお願いします！

```
```

[1]: https://blog.logrocket.com/build-inline-editable-ui-react/ "How to build an inline editable UI in React - LogRocket Blog"
